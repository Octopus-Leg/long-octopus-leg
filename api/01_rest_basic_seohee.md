# 1.RESTful 웹 서비스 기본사항

## 1️⃣ REST API 소개

### API
- API는 한 코드가 다른 코드와 통신할 때 사용되는 수단이다.
- 자바 SDK API가 대표적인 예시이며, 컬렉션, 입출력, 스트림과 같은 다양한 모듈 안에 포함된 클래스를 통해 기능을 제공한다.
- `ArrayList.add()`를 사용할 때 내부 구현을 몰라도 사용법만 보고 쓰는 약속 자체가 API이다.
- 함수를 작성한 후 public 접근 지정자로 외부에 노출하면 다른 클래스에서 이를 호출할 수 있게 된다.
- 이때 노출된 함수 시그니처가 해당 클래스에 대한 API가 된다. (예: `add(int a, int b)`는 Calculator 클래스의 API이다.)
- 클래스나 라이브러리를 통해 노출한 API는 단일 애플리케이션이나 개별 서비스 내의 내부 통신에만 사용된다.
- 두 개 이상의 애플리케이션이 서로 소통해야 하는 필요성이 커지면서 시스템 전반에 걸친 API(system-wide)가 등장하게 되었다.

### RPC, SOAP
- 과거에는 시스템 전반의 통신을 위해 RPC와 SOAP 기반의 서비스를 주로 사용했다.
- **RPC(Remote Procedure Call)**
  - 멀리 떨어진 서버의 함수를 마치 내 컴퓨터에 있는 함수처럼 호출하는 방식이다.
  - 개발자는 네트워크 로직을 몰라도 함수만 호출하면 되며, 최근에는 gRPC와 같은 고성능 방식으로 발전했다.
- **SOAP(Simple Object Access Protocol)**
  - 어떤 시스템이든 엄격한 규칙이 작성된 XML 메시지를 기반으로 확실하게 소통하는 규약이며 HTTP 위에서 동작한다.
  - 보안과 트랜잭션이 매우 중요한 환경에서 표준으로 사용된다. 현재는 보안 영역이 OAuth 등으로 대체되었으나, 금융이나 공공 시스템에서는 여전히 중요하게 사용된다.

### RESTful API
- REST는 소프트웨어 아키텍처 스타일 중 하나인 REpresentational State Transfer의 줄임말이다.
- 이러한 REST 스타일의 제약 조건을 따르는 웹 서비스를 RESTful 웹 서비스라고 부른다.

#### REST의 역사
- SOAP은 이름과 달리 구조가 복잡하고 무거웠던 반면, REST는 통신 방식을 단순화하고 웹의 기반인 HTTP를 적극 활용하여 웹 전반과 내부 네트워크에서 범용적으로 사용될 수 있었다.
- 현재는 대부분의 웹 애플리케이션이 REST API를 사용하고, 최근에는 필요한 데이터만 골라 받을 수 있는 GraphQL도 큰 인기를 얻고 있다.

#### REST의 기본 사항
- **HTTP 기반**: REST는 별도의 프로토콜이 아닌 HTTP 프로토콜 위에서 작동한다.
- **리소스 지향**: 각 URI는 특정 리소스를 의미하므로, 엔드포인트에는 동사가 아닌 **명사**를 사용해야 한다.
  - RPC 스타일(`api/v1/getPersons`) / REST 스타일(`api/v1/persons`)
- **HTTP 메소드 활용**: 리소스에 대한 구체적인 행위(생성, 조회, 수정, 삭제)는 HTTP 메소드의 역할을 통해 구분한다. 리소스는 명사로, 동작은 HTTP 메소드로 표현한다.
- **무상태성(Stateless)**: 서버는 클라이언트의 이전 상태를 기억하지 않는다. 각 요청은 그 자체로 처리에 필요한 모든 정보를 포함해야 하며,
상태 관리는 API가 아닌 클라이언트나 서버의 별도 계층에서 담당한다.
- **캐시 가능성**: HTTP의 표준 캐시 제어 기능을 그대로 사용할 수 있다. 이를 통해 반복되는 요청에 대해 서버 자원을 효율적으로 사용하고 응답 속도를 높일 수 있다.

---

## 2️⃣ 리소스와 URI 다루기
- HTTP 관점에서 WWW 상의 모든 문서는 리소스로 간주된다.
- URI는 웹 리소스의 위치나 이름, 혹은 이 둘 모두를 사용해 리소스를 식별하는 고유한 문자열이다.
- URI에는 리소스의 위치를 나타내는 URL과 고유한 이름을 나타내는 URN이라는 두 가지 타입이 존재한다.

### URI 구문
```
scheme:[//authority]path[?query][#fragment]
```
- **Scheme**: HTTP, HTTPS, FILE, FTP 등이 대표적인 예시이며, 반드시 IANA에 등록된 표준 스킴을 사용해야 한다.
- **Authority**: 선택적 필드로, 사용자 정보와 호스트, 포트라는 하위 컴포넌트로 구성된다.
    - 사용자 정보는 이름과 암호를 포함할 수 있는 선택 사항이며, 이메일 주소(`user@host`)처럼 `@` 기호를 사용해 호스트와 구분한다.
    - 호스트는 IP 주소나 도메인 이름을 포함하며, 포트는 `:` 뒤에 명시하여 특정 서비스 위치를 가리킨다.
- **Path**: `/api/users`와 같이 서버 내 리소스의 계층적 경로를 나타낸다.
- **Query**: `?`로 시작하는 선택적 컴포넌트로, 각 매개변수는 `&`로 구분하고 `=`를 사용해 값을 할당한다.
- **Fragment**: `#`로 시작하며 리소스 내의 부속 리소스나 특정 지점을 가리키는 식별자 역할을 한다.

> **URI 분석 예시**
> `https://api.example.com:8080/api/users/list?page=1&sort=name#top`
> - Scheme: https
> - Authority: api.example.com:8080
> - Path: /api/users/list
> - Query: page=1&sort=name
> - Fragment: #top

### URL이란
- URI가 식별자라면, URL은 리소스를 식별하는 동시에 해당 리소스에 도달할 수 있는 위치와 방법을 함께 알려준다.
- 우리가 웹 브라우저에서 사용하는 전체 웹 주소가 바로 이 URL에 해당한다.

### URN이란
- URN은 urn이라는 스킴으로 시작하는 URI 타입을 의미하며 잘 사용되지 않는다.
- 예를 들어 `urn:oasis:names:specification:docbook:dtd:xml:4.1.2`와 같이 사용된다.

---
## 3️⃣ HTTP 메소드와 상태 코드 살펴보기
### POST
- 주로 리소스 생성에 사용되지만, 예외적으로 읽기(조회) 작업에도 POST를 사용하는 경우가 있다.
- GET 호출의 길이 제한을 초과할 정도로 검색 매개변수가 많은 복잡한 오퍼레이션 상황에서는 POST가 대안이 된다.
- 일반적인 GET 메소드의 쿼리 문자열은 브라우저나 서버에 따라 길이 제한(약 2,048자)이 있는 반면, POST 메소드는 전송 데이터 크기에 실질적인 제한이 없다.
- 입력 매개변수에 비공개 데이터나 보안 정보가 포함된 경우, URL에 정보를 노출하는 GET 대신 리퀘스트 바디를 사용하는 POST 방식을 HTTPS와 결합하여 보안성을 높인다.

### GET
- 일반적으로 리소스 조회에 사용된다.
- 요청이 성공하고 데이터가 포함된 경우 `200 OK` 상태 코드를 반환한다.
- 요청은 성공했으나 응답할 데이터가 본문에 포함되지 않은 경우 원칙적으로 `204 No Content`를 반환하여 데이터가 없음을 명확히 알린다.

### PUT
- 일반적으로 리소스 갱신에 사용된다.

### DELETE
- 일반적으로 리소스 삭제에 사용된다.

### PATCH
- 일반적으로 리소스 부분 갱신에 사용된다.

<details>
<summary>&nbsp; HTTP 상태 코드</summary>

| HTTP 상태 코드 | 설명 |
| :--- | :--- |
| **200 OK** | 요청이 성공적으로 처리되었을 때 사용하는 가장 일반적인 응답이다. |
| **201 Created** | 요청이 성공하여 새로운 리소스가 생성되었음을 의미하며, 주로 POST 등록 성공 시 사용한다. |
| **202 Accepted** | 요청이 접수되었으나 처리가 아직 완료되지 않았음을 의미하며, 비동기 작업 시 사용한다. |
| **204 No Content** | 요청은 성공했으나 응답 바디에 보낼 데이터가 없을 때 사용하며, 보통 수정이나 삭제 성공 시 반환한다. |
| **304 Not Modified** | 리소스가 수정되지 않아 클라이언트가 가진 캐시를 그대로 사용해도 됨을 알려준다. |
| **400 Bad Request** | 잘못된 문법이나 파라미터 등 클라이언트의 잘못된 요청으로 서버가 처리할 수 없는 상태이다. |
| **401 Unauthorized** | 해당 리소스에 접근하기 위해 유효한 인증 정보(로그인)가 필요함을 의미한다. |
| **403 Forbidden** | 사용자의 신원은 확인되었으나, 해당 리소스에 접근할 권한이 없는 상태이다. |
| **404 Not Found** | 요청한 URI에 해당하는 리소스를 서버에서 찾을 수 없을 때 발생한다. |
| **405 Method Not Allowed** | 해당 URI에서 허용되지 않는 HTTP 메소드를 사용한 경우이다. |
| **409 Conflict** | 중복된 아이디 가입 시도처럼 서버의 현재 상태와 요청 데이터가 충돌할 때 발생한다. |
| **429 Too Many Requests** | 정해진 시간 내에 너무 많은 요청을 보내 서버의 처리 제한을 초과한 상태이다. |
| **500 Internal Server Error** | 서버 내부의 로직 오류로 인해 요청을 처리하지 못한 경우 발생하는 일반적인 에러이다. |
| **502 Bad Gateway** | 게이트웨이나 프록시 서버가 상위 서버로부터 잘못된 응답을 받았음을 의미한다. |
| **503 Service Unavailable** | 서버 과부하나 점검으로 인해 일시적으로 요청을 처리할 수 없는 상태이다. |

</details>

---

## 4️⃣ HATEOAS란
- RESTful 웹 서비스는 `HATEOAS(Hypermedia As The Engine Of Application State)`라는 하이퍼미디어를 활용해 클라이언트에게 동적으로 정보를 제공한다.
- 하이퍼미디어는 REST 호출 응답으로 수신하는 콘텐츠의 핵심적인 일부로 포함된다.
- 이러한 하이퍼미디어 콘텐츠에는 단순한 텍스트 링크뿐만 아니라 이미지, 비디오와 같은 다양한 타입의 미디어 리소스로 연결되는 경로가 담겨 있다.
- REST 클라이언트는 사람이 웹 페이지 내의 링크를 클릭하며 정보를 찾아가는 것과 유사한 방식으로, 서버가 제공한 링크를 따라 리소스를 자유롭게 탐색할 수 있다.
- HATEOAS는 REST의 매우 중요한 개념으로 서비스의 상태 전이를 동적으로 표현한다는 점에서 REST와 RPC를 구분하는 핵심적인 기준이 된다.
- 하이퍼미디어는 기존의 텍스트 중심인 하이퍼텍스트에서 한 단계 확장된 개념으로, 모든 형태의 미디어 리소스를 연결 구조에 포함한다.

---

## 5️⃣ REST API 설계 베스트 프랙티스

1. **엔드포인트 경로에서 리소스 이름을 지정할 때 명사형 단어를 사용**
  - 엔드포인트 경로에는 리소스를 나타내는 명사형 단어를 사용하며, 행위는 HTTP 메소드(GET, POST 등)를 통해 표현한다.
2. **엔드포인트 경로에서 컬렉션 리소스의 이름을 지정할 때 복수형을 사용**
  - 리소스들의 집합인 컬렉션을 지칭할 때는 복수형 명사를 사용하여 해당 경로가 데이터의 묶음을 다루고 있음을 명시한다.
특정 리소스를 조회할 때도 `/users/1`과 같이 복수형 경로를 기본으로 사용한다.
3. **하이퍼미디어 사용(HATEOAS)**
  - 응답에 다음 단계의 링크를 포함하면 클라이언트가 직접 URL을 조합할 필요가 없어 개발 비용이 줄어든다. 또한 서버 주소가 변경되어도
응답 내 링크만 수정하면 되므로 클라이언트의 수정 없이 유연한 업그레이드가 가능하다.
4. **API 버전 관리**
  - 서비스 성장에 따른 하위 호환성 유지를 위해 버전 관리는 필수적이다. 주로 URI 경로에 버전을 포함하거나(`v1/users`), HTTP 헤더를 통해 버전을 명시하는 방식을 사용한다.
5. **중첩된 리소스**
  - `/orders/1/payments/1`처럼 리소스를 깊게 중첩하기보다, 마이크로서비스 환경에서는 각 리소스를 독립적으로 식별할 수 있는 `/payments/1` 형식을 더 권장한다.
6. **API 보안**
  - 모든 통신에는 HTTPS를 적용하여 데이터를 암호화한다. REST의 무상태성(Stateless)을 지키기 위해 서버 세션 대신 
JWT나 OAuth 기반의 토큰 인증을 사용하며, 보안 강화를 위해 JWT를 자바스크립트 접근이 불가능한 `HttpOnly` 쿠키에 담아 전송하는 방식을 고려한다.
7. **문서 유지 관리**
  - Swagger나 OpenAPI 등을 활용하여 최신 API 명세를 항상 유지함으로써 클라이언트 개발자와의 원활한 소통을 보장한다.
8. **권장되는 상태 코드 준수**
  - 성공(2xx), 클라이언트 오류(4xx), 서버 오류(5xx) 등 각 상황에 맞는 HTTP 표준 상태 코드를 정확히 사용하여 API의 예측 가능성을 높인다.
9. **캐싱 보장**
  - `Cache-Control`을 통해 유효 기간 내 리소스를 서버 요청 없이 즉시 재사용하거나, `ETag`를 이용한 조건부 요청을 활용한다.
이때 서버가 `304 Not Modified`를 응답하면 실제 데이터(Body) 전송을 생략하여 네트워크 대역폭을 획기적으로 아낄 수 있다.
10. **단위시간당 요청량 제한(Rate limit) 유지 관리**
  - API 남용 및 서비스 과부하를 방지하기 위해 단위 시간당 요청량을 제한하며, 제한을 초과할 경우 `429 Too Many Requests` 코드로 명확히 응답한다.